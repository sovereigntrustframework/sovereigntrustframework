{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Sovereign Trust Framework (STF)","text":"<p>Orchestrating Trust Over IP (ToIP) Components for Self-Sovereign Identity (SSI)</p>"},{"location":"#introduction-to-the-sovereign-trust-framework-stf","title":"Introduction to the Sovereign Trust Framework (STF)","text":"<p>The Sovereign Trust Framework (STF) is an innovative orchestration layer designed to enhance Self-Sovereign Identity (SSI) systems by integrating and extending components from the Trust Over IP (ToIP) Foundation's stack [1]. STF focuses on policy-driven trust management, enabling secure, privacy-preserving interactions in decentralized ecosystems. It contributes to ToIP by providing modular tools for credential orchestration, trust negotiation, and governance interoperability, without competing with existing standards.</p> <p>STF addresses gaps in decentralized trust, such as privacy-preserving feedback and attack resilience, building on protocols like DidTrust [2]. This framework empowers users to control their identifiers, verifiable credentials (VCs), and trust relationships through minimal disclosure and explicit consent.</p>"},{"location":"#high-level-vision","title":"High-Level Vision","text":"<p>STF orchestrates ToIP's four-layer model (public utilities, peer-to-peer communication, credential exchange, and ecosystems) with policy-driven enhancements [1]. It integrates Decentralized Identifiers (DIDs), VCs, and trust registries to facilitate dynamic trust negotiation, as seen in real-world SSI applications discussed at the Internet Identity Workshop (IIW) [3].</p> <p> (Placeholder for a layered stack diagram showing STF atop ToIP components. Create using tools like Draw.io and place in the 'assets' folder.)</p>"},{"location":"#key-principles","title":"Key Principles","text":"Principle Description Governance-Agnostic Supports any governance model without imposing one, aligning with ToIP's flexibility [1]. Transport-Agnostic Works across protocols like DIDComm or HTTP, ensuring broad interoperability. Policy-Schema-Agnostic Accommodates diverse policy formats (e.g., Rego, JSON schemas) for trust rules. Privacy-Preserving by Default Incorporates zero-knowledge proofs and minimal disclosure, inspired by DidTrust's SMPC framework [2]. Composable and Modular Builds on open standards for easy integration. Interoperable and Open Relies on W3C DIDs and VCs for global compatibility."},{"location":"#why-stf-matters","title":"Why STF Matters","text":"<p>In digital ecosystems, trustworthy data exchange is critical, yet centralized identities risk single points of failure [2]. SSI and ToIP address this but lack robust policy orchestration for trust attacks (e.g., Sybil or bad-mouthing) [2]. STF fills this gap by enabling resilient, privacy-focused trust management, as highlighted in discussions on decentralized trust graphs at IIW [3].</p>"},{"location":"#applications","title":"Applications","text":"<ul> <li>Secure Messaging: Policy-enforced encryption for SSI-based communication.</li> <li>Regulatory Compliance: Automated KYC/AML via verifiable credentials, as explored in IIW sessions on SEDI [3].</li> <li>Reputation Systems: Trust scoring in DAOs, resistant to manipulation [2].</li> <li>Citizen Services and IoT: Decentralized access control for public services and devices.</li> </ul>"},{"location":"#resources","title":"Resources","text":"<ul> <li>Getting Started: Tutorials on DIDs, VCs, and policies.</li> <li>Architecture: Detailed layers and protocols.</li> <li>Use Cases: Diagrams and examples.</li> <li>FAQ/Glossary: Key terms defined.</li> </ul> <p>Explore the full documentation in the navigation menu.</p>"},{"location":"#join-the-stf-community","title":"Join the STF Community","text":"<p>STF is an open framework. Contributions, feedback, and proposals from developers, researchers, organizations, and ecosystem partners are welcome.</p> <p>Visit the GitHub repository at:</p> <p>https://github.com/sovereigntrustframework</p>"},{"location":"#author-license","title":"Author &amp; License","text":"<p>Author: Alexandre Cardoso </p> <p>License: Apache 2.0</p>"},{"location":"architecture/","title":"Sovereign Trust Framework \u2014 Architecture","text":"<p>The Sovereign Trust Framework (STF) defines a modular, layered architecture for building interoperable, policy-driven trust systems that remain privacy-preserving, transport-agnostic, and governance-neutral.</p> <p>This document describes the full STF architecture, including all components discussed during design, structured into four main layers. A final section explains how STF maps to the Trust Over IP (ToIP) 4-layer architecture based on the latest information from: https://trustoverip.github.io/TechArch</p>"},{"location":"architecture/#1-stf-layer-overview","title":"1. STF Layer Overview","text":"<pre><code>+-----------------------------------------------------------+\n|                   L4 \u2013 STF-USECASE                       |\n|      (Use-case logic, domain flows, applied trust)        |\n+-----------------------------------------------------------+\n|                   L3 \u2013 STF-POLICY                         |\n|     (VSTP: Verifier-Sovereign Trust Protocol,             |\n|      canonicalization, evaluation modules)                |\n+-----------------------------------------------------------+\n|                   L2 \u2013 STF-COMM                          |\n|   STF-Message + STF-Transport                             |\n|   (VID\u2013cDID mapping, message envelope, transport bridge)   |\n+-----------------------------------------------------------+\n|                   L1 \u2013 STF-IDENTITY                      |\n|    (cDID model, key management, DID/VID abstraction)       |\n+-----------------------------------------------------------+\n</code></pre> <p>Each layer is independent, extensible, and designed for composable deployment.</p>"},{"location":"architecture/#2-layer-1-stf-id-identity-abstraction-layer","title":"2. Layer 1 \u2014 STF-ID (Identity Abstraction Layer)","text":"<p>Layer 1 provides the identity substrate for STF, abstracting DID/VID formats into a unified canonical model.</p>"},{"location":"architecture/#components","title":"Components","text":""},{"location":"architecture/#stf-idm-identity-model","title":"STF-IDM \u2014 Identity Model","text":"<p>Core data structures representing: - cDID (canonical DID) - eDID (ephemeral DID) - VID abstraction (TSP VIDs or other non-DID identifiers)</p>"},{"location":"architecture/#stf-kms-key-management-service","title":"STF-KMS \u2014 Key Management Service","text":"<p>Handles: - key generation - local secure storage - rotation - derivation and export  </p> <p>Tightly integrated with hardware secure modules (TPM, Secure Enclave, Android Keystore).</p>"},{"location":"architecture/#stf-ddm-didvid-derivation-mapping","title":"STF-DDM \u2014 DID/VID Derivation &amp; Mapping","text":"<p>Responsible for: - mapping VID \u2192 cDID using blind/salted derivation - generating fresh ephemeral DIDs - resolving identity metadata locally - anti-correlation salt strategies  </p>"},{"location":"architecture/#stf-idx-identity-index","title":"STF-IDX \u2014 Identity Index","text":"<p>Local privacy-preserving index of known identifiers: - salted hashes - supports lookup by STF-Message and VSTP - prevents correlation by third parties  </p>"},{"location":"architecture/#3-layer-2-stf-comm-communication-layer","title":"3. Layer 2 \u2014 STF-COMM (Communication Layer)","text":"<p>Provides a transport-agnostic communication interface for all STF-enabled applications.</p> <p>Two sublayers:</p>"},{"location":"architecture/#31-stf-message","title":"3.1. STF-Message","text":"<p>Defines the STF envelope and message-level semantics.</p>"},{"location":"architecture/#responsibilities","title":"Responsibilities","text":"<ul> <li>secure VID\u2192cDID resolution  </li> <li>envelope construction  </li> <li>metadata stripping  </li> <li>replay protection and sequencing  </li> <li>inner/outer encryption layers  </li> </ul>"},{"location":"architecture/#modules","title":"Modules","text":"<ul> <li>STF-MSGE \u2014 Message Envelope Format  </li> <li>STF-META \u2014 Metadata Stripping  </li> <li>STF-CRYPTO \u2014 Cryptographic Adaptors  </li> <li>STF-SYNC \u2014 Ordering &amp; Replay Protection  </li> </ul> <p>Supports: - DIDComm (via STF-DCB) - TSP message subsystem - HTTP(S), WebSockets, BLE, NFC, QR  </p>"},{"location":"architecture/#32-stf-transport","title":"3.2. STF-Transport","text":"<p>Abstracts transport protocols into a unified STF transport interface.</p>"},{"location":"architecture/#modules_1","title":"Modules","text":"<ul> <li>STF-TSPB \u2014 TSP Bridge  </li> <li>STF-DCB \u2014 DIDComm Bridge  </li> <li>STF-HTTPE \u2014 HTTP/WS Adapter  </li> <li>STF-P2P \u2014 Peer-to-Peer Adapters (BLE/NFC)</li> </ul>"},{"location":"architecture/#why-stf-transport-is-needed","title":"Why STF-Transport is needed","text":"<p>Even with TSP support, STF-Transport: - normalizes message flows - supports fallback transports - ensures STF semantics even on transports lacking these guarantees - enables DIDComm integration without exposing DID correlation  </p>"},{"location":"architecture/#4-layer-3-stf-policy-policy-claims-attestations-evaluation","title":"4. Layer 3 \u2014 STF-POLICY (Policy, Claims, Attestations, Evaluation)","text":"<p>Layer 3 hosts VSTP (Verifier-Sovereign Trust Protocol) and all trust-evaluation components.</p> <pre><code>Claims \u2192 Canonicalization \u2192 Policy Evaluation \u2192 Trust Result\n</code></pre>"},{"location":"architecture/#components_1","title":"Components","text":""},{"location":"architecture/#stf-vstp-verifier-sovereign-trust-protocol","title":"STF-VSTP \u2014 Verifier-Sovereign Trust Protocol","text":"<p>Implements: - policy-driven evaluation flows - request \u2192 present \u2192 verify \u2192 decision - sovereign local verification by the verifier  </p>"},{"location":"architecture/#stf-canon-canonicalization-module","title":"STF-CANON \u2014 Canonicalization Module","text":"<p>Unifies all claim formats: - Verifiable Credentials - SD-JWT - ISO mDocs - Attestations - Raw claims - Derived claims into a single canonical claim graph.</p>"},{"location":"architecture/#stf-att-attestation-model","title":"STF-ATT \u2014 Attestation Model","text":"<p>Defines: - issuer-driven attestations - signatures - Sybil resistance - trust-weight semantics  </p>"},{"location":"architecture/#stf-cred-credential-interpretation-layer","title":"STF-CRED \u2014 Credential Interpretation Layer","text":"<p>Adapters for: - W3C VC - X.509 - SD-JWT &amp; SD-JWT VC - mDocs  </p>"},{"location":"architecture/#stf-pol-policy-engine-rego","title":"STF-POL \u2014 Policy Engine (Rego)","text":"<p>Implements: - policy evaluation - typed evidence - multi-source policy imports - deterministic results  </p>"},{"location":"architecture/#stf-repute-reputation-engine","title":"STF-REPUTE \u2014 Reputation Engine","text":"<p>Implements: - contextual reputation - weighted attestation graphs - privacy-preserving scoring - Sybil resistance  </p>"},{"location":"architecture/#5-layer-4-stf-usecase-application-domain-logic","title":"5. Layer 4 \u2014 STF-USECASE (Application &amp; Domain Logic)","text":"<p>Contains domain-specific logic using STF.</p>"},{"location":"architecture/#components_2","title":"Components","text":"<ul> <li>STF-UC-CHAT \u2014 private chat using STF-L2 + VSTP  </li> <li>STF-UC-KYC \u2014 age/identity verification  </li> <li>STF-UC-CONTACT \u2014 trusted contact exchange  </li> <li>STF-UC-TRUSTLIST \u2014 local trust circle management  </li> <li>STF-UC-GOV \u2014 governance overlays (issuer bundles, trust schemas)</li> </ul>"},{"location":"architecture/#6-cross-layer-modules","title":"6. Cross-Layer Modules","text":""},{"location":"architecture/#stf-log-privacy-safe-logging","title":"STF-LOG \u2014 Privacy-safe Logging","text":""},{"location":"architecture/#stf-priv-privacy-guard","title":"STF-PRIV \u2014 Privacy Guard","text":"<p>Enforces: - no cDID leakage - salt regeneration - ephemeral-only outward identifiers  </p>"},{"location":"architecture/#stf-storage-encrypted-storage","title":"STF-STORAGE \u2014 Encrypted Storage","text":"<p>Stores: - keys - credentials - attestations - policies - transport state  </p>"},{"location":"architecture/#7-complete-architecture-diagram-ascii","title":"7. Complete Architecture Diagram (ASCII)","text":"<pre><code>+--------------------------------------------------------------------+\n|                         L4 \u2013 STF-USECASE                           |\n|    UC-CHAT | UC-KYC | UC-CONTACT | UC-TRUSTLIST | UC-GOV           |\n+--------------------------------------------------------------------+\n|                         L3 \u2013 STF-POLICY                            |\n|  VSTP | CANON | ATT | CRED | POL | REPUTE                          |\n+--------------------------------------------------------------------+\n|                         L2 \u2013 STF-COMM                              |\n|  STF-MSGE | STF-META | STF-CRYPTO | STF-SYNC                       |\n|  STF-TSPB | STF-DCB | STF-HTTPE | STF-P2P                          |\n+--------------------------------------------------------------------+\n|                         L1 \u2013 STF-ID                                |\n|  IDM | KMS | DDM | IDX                                              |\n+--------------------------------------------------------------------+\n|                   Local Storage &amp; Privacy Modules                  |\n|        LOG | PRIV | STORAGE                                        |\n+--------------------------------------------------------------------+\n</code></pre>"},{"location":"architecture/#8-stf-mapping-to-the-trust-over-ip-toip-stack","title":"8. STF Mapping to the Trust Over IP (ToIP) Stack","text":"<p>The ToIP stack defines four technology layers plus a governance stack. STF maps cleanly into these layers as follows, based on: https://trustoverip.github.io/TechArch</p>"},{"location":"architecture/#81-toip-layer-overview","title":"8.1. ToIP Layer Overview","text":"ToIP Layer Role Layer 1 \u2014 Trust Support Cryptography, keys, secure storage, identity binding Layer 2 \u2014 Trust Spanning Universal interoperable messaging (e.g., TSP) Layer 3 \u2014 Trust Tasks Credential exchange, proof presentation, trust decisions Layer 4 \u2014 Trust Applications User-facing apps (wallets, KYC, chat, etc.) Governance Stack Rules, registries, trust frameworks, policy governance"},{"location":"architecture/#82-stf-toip-mapping-table","title":"8.2. STF \u2192 ToIP Mapping Table","text":"STF Layer / Module Maps to ToIP Layer Description STF-IDENTITY (L1) ToIP Layer 1 \u2014 Trust Support cDID model, VID abstraction, keys, secure storage STF-COMM (L2) ToIP Layer 2 \u2014 Trust Spanning STF-Message + STF-Transport, bridges for TSP and DIDComm STF-POLICY (L3) ToIP Layer 3 \u2014 Trust Tasks VSTP, credential evaluation, attestations, reputation STF-USECASE (L4) ToIP Layer 4 \u2014 Trust Applications Chat, KYC, contact exchange, trust lists STF-GOV (future) ToIP Governance Stack Issuer bundles, trust schemas, governance rules"},{"location":"architecture/#83-visual-mapping-diagram-mermaid","title":"8.3. Visual Mapping Diagram (Mermaid)","text":"<pre><code>flowchart TB\n\n    subgraph toip[ToIP Technology Stack]\n        direction TB\n        T4[Layer 4 \u2022 Trust Applications]\n        T3[Layer 3 \u2022 Trust Tasks]\n        T2[Layer 2 \u2022 Trust Spanning]\n        T1[Layer 1 \u2022 Trust Support]\n    end\n\n    subgraph stf[STF Architecture]\n        direction TB\n        S4[STF-USECASE]\n        S3[STF-POLICY]\n        S2[STF-COMM]\n        S1[STF-IDENTITY]\n    end\n\n    T4 --- S4\n    T3 --- S3\n    T2 --- S2\n    T1 --- S1\n</code></pre>"},{"location":"architecture/#9-summary","title":"9. Summary","text":"<p>STF:</p> <ul> <li>aligns cleanly with the ToIP 4-layer model  </li> <li>provides a complete technical foundation for ToIP-based ecosystems  </li> <li>is fully transport-agnostic and governance-agnostic  </li> <li>supports TSP, DIDComm, and future transports  </li> <li>enables policy-driven sovereign trust decisions  </li> <li>offers a strong privacy-preserving design  </li> </ul>"},{"location":"STF-IDENTITY/canonicaldid/","title":"Canonical DID (cDID)","text":"<p>The canonical DID (cDID) is the internal, never-exposed, privacy-preserving identity anchor used by the Sovereign Trust Framework (STF). It is the foundation of STF-IDENTITY, providing a common internal identity abstraction independent of DID methods, transport protocols, or VID formats.</p> <p>The cDID provides:</p> <ul> <li>A stable identity anchor for local trust and reputation  </li> <li>Strong unlinkability across sessions and relationships  </li> <li>Mapping between external identifiers (DIDs, VIDs, others)  </li> <li>Integration with STF-POLICY (VSTP) and STF-COMM layers  </li> <li>A unifying identity representation for all STF components  </li> </ul> <p>The cDID is never shared over the network and never written to a ledger.</p>"},{"location":"STF-IDENTITY/canonicaldid/#1-purpose-of-the-canonical-did","title":"1. Purpose of the Canonical DID","text":"<p>STF is identity-agnostic: DIDs, VIDs, peer DIDs, ephemeral identifiers, and transport-native IDs may all appear in Layer 2.</p> <p>However, STF requires one stable, internal identifier for:</p> <ul> <li>Policy evaluation (STF-POL)  </li> <li>Reputation aggregation (STF-REPUTE)  </li> <li>Attestation weighting (STF-ATT)  </li> <li>Message verification context (STF-Message)  </li> <li>Local identity indexing (STF-IDX)  </li> </ul> <p>Thus the cDID serves as:</p> <p>\u201cA canonical internal representation of an external identity, derived in a privacy-preserving way.\u201d</p>"},{"location":"STF-IDENTITY/canonicaldid/#2-what-the-cdid-is-not","title":"2. What the cDID Is Not","text":"<p>To clarify its role:</p> <p>\u274c It is not a public DID \u274c It is not resolvable \u274c It is not a fixed identifier shared between devices \u274c It is not method-specific \u274c It is not used for routing or transport  </p> <p>The cDID is local-only and device-bound.</p>"},{"location":"STF-IDENTITY/canonicaldid/#3-how-cdid-fits-into-stf-identity-layer","title":"3. How cDID Fits into STF Identity Layer","text":"<pre><code>external identifiers \u2192 eDID (ephemeral) \u2192 cDID (canonical, internal)\n</code></pre> <p>Supported external identifiers:</p> <ul> <li>DID (all methods)</li> <li>DID:peer</li> <li>TSP VID</li> <li>Derived session identifiers</li> <li>Application-native identifiers (optional)</li> <li>Phone/email (optional mapping, privacy-safe if hashed)</li> <li>QR-scanned contact handles</li> <li>Local contact book entries</li> </ul> <p>The canonical DID becomes the internal identity anchor.</p>"},{"location":"STF-IDENTITY/canonicaldid/#4-formal-definition-of-cdid","title":"4. Formal Definition of cDID","text":"<p>A cDID is a deterministic, salted, device-local identifier generated from an input identity:</p> <pre><code>cDID = hash( normalize(external_identifier) + salt_epoch + device_secret )\n</code></pre> <p>Characteristics:</p> <ul> <li>Deterministic within an epoch </li> <li>Different across devices </li> <li>Different across epochs </li> <li>Impossible to reconstruct externally </li> <li>Impossible to link across epochs </li> </ul> <p>The normalization step ensures input format neutrality.</p>"},{"location":"STF-IDENTITY/canonicaldid/#5-normalization-function","title":"5. Normalization Function","text":"<p>The input identifier must be canonicalized before hashing.</p> <pre><code>normalized_id = Normalize(external_identifier)\n</code></pre> <p>Normalization rules:</p> <ol> <li>Trim whitespace.</li> <li>Lowercase unless case-sensitive DID spec requires otherwise.</li> <li>Collapse equivalent encodings (<code>did:key:z...</code> vs multibase raw key).</li> <li>For VIDs, turn them into UTF-8 safe binary form.</li> <li>For QR-based identifiers or phone/email:</li> <li>Normalize email: lowercase, remove dots for Gmail-like systems.</li> <li>Normalize phone: E.164 format.</li> </ol> <p>This ensures stable results even if identifiers come in multiple formats.</p>"},{"location":"STF-IDENTITY/canonicaldid/#6-derivation-algorithm-reference-implementation","title":"6. Derivation Algorithm (Reference Implementation)","text":"<pre><code>function derive_cdid(external_identifier):\n    normalized = Normalize(external_identifier)\n    epoch_salt = current_salt()\n    input = normalized || epoch_salt || device_secret\n    return H(input)\n</code></pre> <p>Where:</p> <ul> <li><code>H</code> = SHA-256 / BLAKE3 (configurable)</li> <li><code>device_secret</code> = secret key only stored locally</li> <li><code>epoch_salt</code> = rotating salt (see section below)</li> </ul> <p>Output:</p> <ul> <li>256-bit canonical identity string</li> <li>Represented as: <code>cdid:z&lt;multibase-encoded-value&gt;</code></li> </ul> <p>Example:</p> <pre><code>cdid:z4Bx9Kk2vWuF1g8qZdD9tP9yLN8oGfP7F2kzMhZq9mSs\n</code></pre>"},{"location":"STF-IDENTITY/canonicaldid/#7-salt-rotation","title":"7. Salt Rotation","text":"<p>The cDID must evolve over time to preserve unlinkability.</p> <p>Salt rotation schedule:</p> <ul> <li>Rotate every N days (default: 30 days)</li> <li>Rotation triggered when:</li> <li>time threshold reached  </li> <li>device recovers a backup  </li> <li>user rotates keys manually  </li> </ul> <p>Salt storage:</p> <ul> <li>Each salt epoch stored locally:</li> <li><code>salt_2025-01</code></li> <li><code>salt_2025-02</code></li> <li>Keeps a finite window (e.g., last 3 epochs) to maintain backward compatibility.</li> </ul> <p>Important: Old cDIDs remain functional for reputation but cannot be linked to new ones externally.</p>"},{"location":"STF-IDENTITY/canonicaldid/#8-storage-model","title":"8. Storage Model","text":"<p>All cDID data resides under STF-STORAGE, protected via:</p> <ul> <li>OS secure storage  </li> <li>hardware secure module (TPM/SE/Keystore) where available  </li> <li>encrypted local database  </li> </ul> <p>Storage structure:</p> <pre><code>/identity/\n    device_secret\n    epoch_salts/\n        salt_2025-01\n        salt_2025-02\n        ...\n    mapping/\n        cdid_index.db   (stores mapping external\u2192cDID)\n        reversed_mapping.db (optional, encrypted, prevents leaks)\n</code></pre> <p>Privacy protections:</p> <ul> <li>No external identifier is stored in plaintext</li> <li>External identifiers hashed and salted with a different salt</li> <li>Mapping is one-way unless device_secret is known</li> </ul>"},{"location":"STF-IDENTITY/canonicaldid/#9-how-cdid-interacts-with-other-stf-components","title":"9. How cDID Interacts with Other STF Components","text":""},{"location":"STF-IDENTITY/canonicaldid/#91-with-stf-message-l2","title":"9.1 With STF-Message (L2)","text":"<ul> <li>When a message arrives with DID/VID:</li> <li>normalize and derive cDID  </li> <li>load associated state (session keys, policies, reputation, etc.)  </li> <li>Outgoing messages never contain the cDID.</li> </ul>"},{"location":"STF-IDENTITY/canonicaldid/#92-with-stf-transport-l2","title":"9.2 With STF-Transport (L2)","text":"<ul> <li>VID \u2192 cDID mapping performed before message envelope processing  </li> <li>DIDComm route resolution uses the mapped cDID for session context  </li> </ul>"},{"location":"STF-IDENTITY/canonicaldid/#93-with-stf-policy-l3","title":"9.3 With STF-POLICY (L3)","text":"<ul> <li>Policy evaluation uses cDID as the subject </li> <li>Canonical claims attach to the cDID  </li> <li>Rego rules refer to cDID instead of DID  </li> </ul> <p>Example:</p> <pre><code>allow_response {\n   trust_score[cDID] &gt; 75\n}\n</code></pre>"},{"location":"STF-IDENTITY/canonicaldid/#94-with-stf-repute-l3","title":"9.4 With STF-REPUTE (L3)","text":"<ul> <li>Reputation is stored per-cDID  </li> <li>Attestations apply to canonical identities  </li> </ul>"},{"location":"STF-IDENTITY/canonicaldid/#95-with-stf-att-l3","title":"9.5 With STF-ATT (L3)","text":"<ul> <li>Attestations are bound to cDID locally  </li> <li>Device enforces: \"Issued-to\" cDID must match derived value  </li> </ul>"},{"location":"STF-IDENTITY/canonicaldid/#10-when-cdid-is-recomputed-vs-reused","title":"10. When cDID is Recomputed vs. Reused","text":"Scenario Uses new cDID? Notes Same user, same epoch \u274c Stable identity anchor New epoch (salt rotates) \u2714 Preserves unlinkability Device restored from backup \u274c (if device_secret preserved) Stable identity Multi-device use \u2714 No cross-device linking User resets identity \u2714 New device_secret"},{"location":"STF-IDENTITY/canonicaldid/#11-should-cdid-use-its-own-did-method","title":"11. Should cDID Use Its Own DID Method?","text":"<p>cDID can optionally be defined as a private DID method:</p> <pre><code>did:stf:&lt;encoded_value&gt;\n</code></pre> <p>But this is only recommended for:</p> <ul> <li>internal debugging</li> <li>optional internal API traces</li> <li>representing cDID-like objects in logs</li> </ul> <p>IMPORTANT: This DID method MUST NEVER be transmitted externally.</p>"},{"location":"STF-IDENTITY/canonicaldid/#12-example-cdid-lifecycle","title":"12. Example cDID Lifecycle","text":"<pre><code>1. Bob receives Alice\u2019s DID or VID\n2. STF performs Normalize(DID)\n3. Epoch salt is applied\n4. cDID derived\n5. Trust score and attestations linked to this cDID\n6. Next month salt rotates\n7. Old cDID archived as \"epoch-1\"\n8. New cDID used going forward\n</code></pre>"},{"location":"STF-IDENTITY/canonicaldid/#13-security-privacy-guarantees","title":"13. Security &amp; Privacy Guarantees","text":"<ul> <li>Unlinkability: No two parties can correlate Alice\u2019s identities.</li> <li>Local-only: No network exposure.</li> <li>Sybil mitigation: Combined with STF-ATT and STF-REPUTE.</li> <li>No ledger dependency.</li> <li>Minimal attack surface.</li> </ul>"},{"location":"STF-IDENTITY/canonicaldid/#14-future-extensions","title":"14. Future Extensions","text":"<ul> <li>Multi-device canonical identity synchronization with privacy guarantees  </li> <li>Multi-party blinded attestations  </li> <li>cDID versioning for DIDComm 2.0 compatibility  </li> <li>Selective correlation via user-consented export  </li> </ul>"},{"location":"STF-IDENTITY/canonicaldid/#15-summary","title":"15. Summary","text":"<p>The canonical DID (cDID) is the foundational identity abstraction mechanism of STF Layer 1.</p> <p>It:</p> <ul> <li>unifies all external identifiers  </li> <li>ensures privacy and unlinkability  </li> <li>anchors policy and reputation  </li> <li>integrates deeply across STF layers  </li> <li>is never exposed  </li> <li>is derived using deterministic, rotating, privacy-preserving methods  </li> </ul> <p>This mechanism ensures STF remains privacy-first, transport-agnostic, DID-method-agnostic, and future-proof.</p>"}]}